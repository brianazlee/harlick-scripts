{"version":3,"sources":["node_modules/arrive/src/arrive.js","index.tsx"],"names":[],"mappings":"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","file":"index.js","sourceRoot":"..","sourcesContent":["/*globals jQuery,Window,HTMLElement,HTMLDocument,HTMLCollection,NodeList,MutationObserver */\n/*exported Arrive*/\n/*jshint latedef:false */\n\n/*\n * arrive.js\n * v2.4.1\n * https://github.com/uzairfarooq/arrive\n * MIT licensed\n *\n * Copyright (c) 2014-2017 Uzair Farooq\n */\nvar Arrive = (function(window, $, undefined) {\n\n  \"use strict\";\n\n  if(!window.MutationObserver || typeof HTMLElement === 'undefined'){\n    return; //for unsupported browsers\n  }\n\n  var arriveUniqueId = 0;\n\n  var utils = (function() {\n    var matches = HTMLElement.prototype.matches || HTMLElement.prototype.webkitMatchesSelector || HTMLElement.prototype.mozMatchesSelector\n                  || HTMLElement.prototype.msMatchesSelector;\n\n    return {\n      matchesSelector: function(elem, selector) {\n        return elem instanceof HTMLElement && matches.call(elem, selector);\n      },\n      // to enable function overloading - By John Resig (MIT Licensed)\n      addMethod: function (object, name, fn) {\n        var old = object[ name ];\n        object[ name ] = function(){\n          if ( fn.length == arguments.length ) {\n            return fn.apply( this, arguments );\n          }\n          else if ( typeof old == 'function' ) {\n            return old.apply( this, arguments );\n          }\n        };\n      },\n      callCallbacks: function(callbacksToBeCalled, registrationData) {\n        if (registrationData && registrationData.options.onceOnly && registrationData.firedElems.length == 1) {\n          // as onlyOnce param is true, make sure we fire the event for only one item\n          callbacksToBeCalled = [callbacksToBeCalled[0]];\n        }\n\n        for (var i = 0, cb; (cb = callbacksToBeCalled[i]); i++) {\n          if (cb && cb.callback) {\n            cb.callback.call(cb.elem, cb.elem);\n          }\n        }\n\n        if (registrationData && registrationData.options.onceOnly && registrationData.firedElems.length == 1) {\n          // unbind event after first callback as onceOnly is true.\n          registrationData.me.unbindEventWithSelectorAndCallback.call(\n            registrationData.target, registrationData.selector, registrationData.callback);\n        }\n      },\n      // traverse through all descendants of a node to check if event should be fired for any descendant\n      checkChildNodesRecursively: function(nodes, registrationData, matchFunc, callbacksToBeCalled) {\n        // check each new node if it matches the selector\n        for (var i=0, node; (node = nodes[i]); i++) {\n          if (matchFunc(node, registrationData, callbacksToBeCalled)) {\n            callbacksToBeCalled.push({ callback: registrationData.callback, elem: node });\n          }\n\n          if (node.childNodes.length > 0) {\n            utils.checkChildNodesRecursively(node.childNodes, registrationData, matchFunc, callbacksToBeCalled);\n          }\n        }\n      },\n      mergeArrays: function(firstArr, secondArr){\n        // Overwrites default options with user-defined options.\n        var options = {},\n            attrName;\n        for (attrName in firstArr) {\n          if (firstArr.hasOwnProperty(attrName)) {\n            options[attrName] = firstArr[attrName];\n          }\n        }\n        for (attrName in secondArr) {\n          if (secondArr.hasOwnProperty(attrName)) {\n            options[attrName] = secondArr[attrName];\n          }\n        }\n        return options;\n      },\n      toElementsArray: function (elements) {\n        // check if object is an array (or array like object)\n        // Note: window object has .length property but it's not array of elements so don't consider it an array\n        if (typeof elements !== \"undefined\" && (typeof elements.length !== \"number\" || elements === window)) {\n          elements = [elements];\n        }\n        return elements;\n      }\n    };\n  })();\n\n\n  // Class to maintain state of all registered events of a single type\n  var EventsBucket = (function() {\n    var EventsBucket = function() {\n      // holds all the events\n\n      this._eventsBucket    = [];\n      // function to be called while adding an event, the function should do the event initialization/registration\n      this._beforeAdding    = null;\n      // function to be called while removing an event, the function should do the event destruction\n      this._beforeRemoving  = null;\n    };\n\n    EventsBucket.prototype.addEvent = function(target, selector, options, callback) {\n      var newEvent = {\n        target:             target,\n        selector:           selector,\n        options:            options,\n        callback:           callback,\n        firedElems:         []\n      };\n\n      if (this._beforeAdding) {\n        this._beforeAdding(newEvent);\n      }\n\n      this._eventsBucket.push(newEvent);\n      return newEvent;\n    };\n\n    EventsBucket.prototype.removeEvent = function(compareFunction) {\n      for (var i=this._eventsBucket.length - 1, registeredEvent; (registeredEvent = this._eventsBucket[i]); i--) {\n        if (compareFunction(registeredEvent)) {\n          if (this._beforeRemoving) {\n              this._beforeRemoving(registeredEvent);\n          }\n\n          // mark callback as null so that even if an event mutation was already triggered it does not call callback\n          var removedEvents = this._eventsBucket.splice(i, 1);\n          if (removedEvents && removedEvents.length) {\n            removedEvents[0].callback = null;\n          }\n        }\n      }\n    };\n\n    EventsBucket.prototype.beforeAdding = function(beforeAdding) {\n      this._beforeAdding = beforeAdding;\n    };\n\n    EventsBucket.prototype.beforeRemoving = function(beforeRemoving) {\n      this._beforeRemoving = beforeRemoving;\n    };\n\n    return EventsBucket;\n  })();\n\n\n  /**\n   * @constructor\n   * General class for binding/unbinding arrive and leave events\n   */\n  var MutationEvents = function(getObserverConfig, onMutation) {\n    var eventsBucket    = new EventsBucket(),\n        me              = this;\n\n    var defaultOptions = {\n      fireOnAttributesModification: false\n    };\n\n    // actual event registration before adding it to bucket\n    eventsBucket.beforeAdding(function(registrationData) {\n      var\n        target    = registrationData.target,\n        observer;\n\n      // mutation observer does not work on window or document\n      if (target === window.document || target === window) {\n        target = document.getElementsByTagName(\"html\")[0];\n      }\n\n      // Create an observer instance\n      observer = new MutationObserver(function(e) {\n        onMutation.call(this, e, registrationData);\n      });\n\n      var config = getObserverConfig(registrationData.options);\n\n      observer.observe(target, config);\n\n      registrationData.observer = observer;\n      registrationData.me = me;\n    });\n\n    // cleanup/unregister before removing an event\n    eventsBucket.beforeRemoving(function (eventData) {\n      eventData.observer.disconnect();\n    });\n\n    this.bindEvent = function(selector, options, callback) {\n      options = utils.mergeArrays(defaultOptions, options);\n\n      var elements = utils.toElementsArray(this);\n\n      for (var i = 0; i < elements.length; i++) {\n        eventsBucket.addEvent(elements[i], selector, options, callback);\n      }\n    };\n\n    this.unbindEvent = function() {\n      var elements = utils.toElementsArray(this);\n      eventsBucket.removeEvent(function(eventObj) {\n        for (var i = 0; i < elements.length; i++) {\n          if (this === undefined || eventObj.target === elements[i]) {\n            return true;\n          }\n        }\n        return false;\n      });\n    };\n\n    this.unbindEventWithSelectorOrCallback = function(selector) {\n      var elements = utils.toElementsArray(this),\n          callback = selector,\n          compareFunction;\n\n      if (typeof selector === \"function\") {\n        compareFunction = function(eventObj) {\n          for (var i = 0; i < elements.length; i++) {\n            if ((this === undefined || eventObj.target === elements[i]) && eventObj.callback === callback) {\n              return true;\n            }\n          }\n          return false;\n        };\n      }\n      else {\n        compareFunction = function(eventObj) {\n          for (var i = 0; i < elements.length; i++) {\n            if ((this === undefined || eventObj.target === elements[i]) && eventObj.selector === selector) {\n              return true;\n            }\n          }\n          return false;\n        };\n      }\n      eventsBucket.removeEvent(compareFunction);\n    };\n\n    this.unbindEventWithSelectorAndCallback = function(selector, callback) {\n      var elements = utils.toElementsArray(this);\n      eventsBucket.removeEvent(function(eventObj) {\n          for (var i = 0; i < elements.length; i++) {\n            if ((this === undefined || eventObj.target === elements[i]) && eventObj.selector === selector && eventObj.callback === callback) {\n              return true;\n            }\n          }\n          return false;\n      });\n    };\n\n    return this;\n  };\n\n\n  /**\n   * @constructor\n   * Processes 'arrive' events\n   */\n  var ArriveEvents = function() {\n    // Default options for 'arrive' event\n    var arriveDefaultOptions = {\n      fireOnAttributesModification: false,\n      onceOnly: false,\n      existing: false\n    };\n\n    function getArriveObserverConfig(options) {\n      var config = {\n        attributes: false,\n        childList: true,\n        subtree: true\n      };\n\n      if (options.fireOnAttributesModification) {\n        config.attributes = true;\n      }\n\n      return config;\n    }\n\n    function onArriveMutation(mutations, registrationData) {\n      mutations.forEach(function( mutation ) {\n        var newNodes    = mutation.addedNodes,\n            targetNode = mutation.target,\n            callbacksToBeCalled = [],\n            node;\n\n        // If new nodes are added\n        if( newNodes !== null && newNodes.length > 0 ) {\n          utils.checkChildNodesRecursively(newNodes, registrationData, nodeMatchFunc, callbacksToBeCalled);\n        }\n        else if (mutation.type === \"attributes\") {\n          if (nodeMatchFunc(targetNode, registrationData, callbacksToBeCalled)) {\n            callbacksToBeCalled.push({ callback: registrationData.callback, elem: targetNode });\n          }\n        }\n\n        utils.callCallbacks(callbacksToBeCalled, registrationData);\n      });\n    }\n\n    function nodeMatchFunc(node, registrationData, callbacksToBeCalled) {\n      // check a single node to see if it matches the selector\n      if (utils.matchesSelector(node, registrationData.selector)) {\n        if(node._id === undefined) {\n          node._id = arriveUniqueId++;\n        }\n        // make sure the arrive event is not already fired for the element\n        if (registrationData.firedElems.indexOf(node._id) == -1) {\n          registrationData.firedElems.push(node._id);\n\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    arriveEvents = new MutationEvents(getArriveObserverConfig, onArriveMutation);\n\n    var mutationBindEvent = arriveEvents.bindEvent;\n\n    // override bindEvent function\n    arriveEvents.bindEvent = function(selector, options, callback) {\n\n      if (typeof callback === \"undefined\") {\n        callback = options;\n        options = arriveDefaultOptions;\n      } else {\n        options = utils.mergeArrays(arriveDefaultOptions, options);\n      }\n\n      var elements = utils.toElementsArray(this);\n\n      if (options.existing) {\n        var existing = [];\n\n        for (var i = 0; i < elements.length; i++) {\n          var nodes = elements[i].querySelectorAll(selector);\n          for (var j = 0; j < nodes.length; j++) {\n            existing.push({ callback: callback, elem: nodes[j] });\n          }\n        }\n\n        // no need to bind event if the callback has to be fired only once and we have already found the element\n        if (options.onceOnly && existing.length) {\n          return callback.call(existing[0].elem, existing[0].elem);\n        }\n\n        setTimeout(utils.callCallbacks, 1, existing);\n      }\n\n      mutationBindEvent.call(this, selector, options, callback);\n    };\n\n    return arriveEvents;\n  };\n\n\n  /**\n   * @constructor\n   * Processes 'leave' events\n   */\n  var LeaveEvents = function() {\n    // Default options for 'leave' event\n    var leaveDefaultOptions = {};\n\n    function getLeaveObserverConfig() {\n      var config = {\n        childList: true,\n        subtree: true\n      };\n\n      return config;\n    }\n\n    function onLeaveMutation(mutations, registrationData) {\n      mutations.forEach(function( mutation ) {\n        var removedNodes  = mutation.removedNodes,\n            callbacksToBeCalled = [];\n\n        if( removedNodes !== null && removedNodes.length > 0 ) {\n          utils.checkChildNodesRecursively(removedNodes, registrationData, nodeMatchFunc, callbacksToBeCalled);\n        }\n\n        utils.callCallbacks(callbacksToBeCalled, registrationData);\n      });\n    }\n\n    function nodeMatchFunc(node, registrationData) {\n      return utils.matchesSelector(node, registrationData.selector);\n    }\n\n    leaveEvents = new MutationEvents(getLeaveObserverConfig, onLeaveMutation);\n\n    var mutationBindEvent = leaveEvents.bindEvent;\n\n    // override bindEvent function\n    leaveEvents.bindEvent = function(selector, options, callback) {\n\n      if (typeof callback === \"undefined\") {\n        callback = options;\n        options = leaveDefaultOptions;\n      } else {\n        options = utils.mergeArrays(leaveDefaultOptions, options);\n      }\n\n      mutationBindEvent.call(this, selector, options, callback);\n    };\n\n    return leaveEvents;\n  };\n\n\n  var arriveEvents = new ArriveEvents(),\n      leaveEvents  = new LeaveEvents();\n\n  function exposeUnbindApi(eventObj, exposeTo, funcName) {\n    // expose unbind function with function overriding\n    utils.addMethod(exposeTo, funcName, eventObj.unbindEvent);\n    utils.addMethod(exposeTo, funcName, eventObj.unbindEventWithSelectorOrCallback);\n    utils.addMethod(exposeTo, funcName, eventObj.unbindEventWithSelectorAndCallback);\n  }\n\n  /*** expose APIs ***/\n  function exposeApi(exposeTo) {\n    exposeTo.arrive = arriveEvents.bindEvent;\n    exposeUnbindApi(arriveEvents, exposeTo, \"unbindArrive\");\n\n    exposeTo.leave = leaveEvents.bindEvent;\n    exposeUnbindApi(leaveEvents, exposeTo, \"unbindLeave\");\n  }\n\n  if ($) {\n    exposeApi($.fn);\n  }\n  exposeApi(HTMLElement.prototype);\n  exposeApi(NodeList.prototype);\n  exposeApi(HTMLCollection.prototype);\n  exposeApi(HTMLDocument.prototype);\n  exposeApi(Window.prototype);\n\n  var Arrive = {};\n  // expose functions to unbind all arrive/leave events\n  exposeUnbindApi(arriveEvents, Arrive, \"unbindAllArrive\");\n  exposeUnbindApi(leaveEvents, Arrive, \"unbindAllLeave\");\n\n  return Arrive;\n\n})(window, typeof jQuery === 'undefined' ? null : jQuery, undefined);","import 'arrive';\n\nconst PRICE_REGEX = /\\+\\$?([0-9.]+)/;\n\nfunction handleFormVisible(formEl: Element) {\n  const labels = Array.from(formEl.querySelectorAll('label'));\n\n  const breakdownContainer = document.createElement('div');\n  breakdownContainer.classList.add('cost-breakdown');\n\n  const cost = document.createElement('h4');\n  cost.classList.add('cost');\n\n  breakdownContainer.append(cost);\n\n  const buttons = formEl.querySelector('.form-button-wrapper');\n\n  if (buttons !== null) {\n    buttons.insertAdjacentElement('beforebegin', breakdownContainer);\n  }\n\n  // Get all labels + prices associated to the label being selected\n  const extraCostLabels = labels\n    .map(label => {\n      const costMatch = label.innerText.match(PRICE_REGEX);\n\n      if (costMatch === null) {\n        return null;\n      }\n\n      return {label: label, cost: costMatch[1]};\n    })\n    .filter(value => value !== null);\n\n  const computeTotalPrice = () => {\n    const price = extraCostLabels\n      .map(obj =>\n        obj?.label?.querySelector('input')?.checked ? parseInt(obj.cost, 10) : 0\n      )\n      .reduce((acc, value) => acc + value, 0);\n\n    cost.innerText = 'Estimated Additional Cost: $' + price.toFixed(2);\n  };\n\n  // Assign handlers to compute the updated price each time the labels change\n  labels.forEach(label => {\n    const input = label.querySelector('input');\n\n    if (input) {\n      input.addEventListener('change', computeTotalPrice);\n    }\n  });\n\n  computeTotalPrice();\n\n  // Convert labels into selectable items\n  const fieldsets = Array.from(formEl.querySelectorAll('fieldset'));\n\n  fieldsets.forEach(fieldset => {\n    const description = fieldset.querySelector<HTMLDivElement>('.description');\n\n    if (description === null) {\n      return;\n    }\n\n    description.style.display = 'none';\n\n    const options = Array.from(fieldset.querySelectorAll<HTMLDivElement>('.option'));\n\n    options.forEach(option => {\n      option.querySelector('input')!.style.display = 'none';\n      const optionName = option.innerText.trim();\n      const optionLabel = option.querySelector('label')!;\n      const optionDesc = fieldset.querySelector(\n        '.description [data-option-for=\"' + optionName + '\"]'\n      );\n\n      if (optionDesc === null) {\n        return;\n      }\n\n      // Remove the text node and append the description\n      optionLabel.childNodes[1].remove();\n      optionLabel.append(optionDesc);\n    });\n\n    const legends = Array.from(\n      fieldset.querySelectorAll<HTMLLegendElement>('fieldset legend')\n    );\n\n    legends.forEach(function (legend) {\n      const name = legend.innerText.trim();\n\n      const desc = fieldset.querySelector(\n        '.description [data-description-for=\"' + name + '\"]'\n      );\n\n      if (desc === null) {\n        return;\n      }\n\n      legend.after(desc);\n    });\n  });\n}\n\ndocument.arrive('[data-form-id=\"600bcf825b984430bfeca409\"]', handleFormVisible);\n"]}